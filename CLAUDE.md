# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## What This Is

Vibe Player — a custom web video player built with React 19, TypeScript, and Shaka Player 5 for adaptive streaming (DASH/HLS). Replaces native browser controls with a dark-themed custom overlay. Supports ClearKey DRM auto-detection, multi-track audio/subtitles, playback diagnostics, and sleep/wake recovery.

## Commands

- `npm run dev` — Start Vite dev server with HMR
- `npm run build` — TypeScript check + Vite production build
- `npm run lint` — ESLint (flat config, ESLint 9+)
- `npm run test` — Vitest in watch mode
- `npm run test:run` — Vitest single run (CI mode)
- `npm run test:coverage` — Coverage report
- Run a single test file: `npx vitest run src/utils/formatTime.test.ts`

## Architecture

Entry: `index.html` → `src/main.tsx` → `src/App.tsx`

**App.tsx** — Root component. Renders a URL input form; on submit passes the manifest URL to ShakaPlayer.

**ShakaPlayer** (`src/components/ShakaPlayer.tsx`) — Bridge between React and the native Shaka Player library. Handles:
- One-time polyfill installation at module level
- Manifest fetching to auto-detect ClearKey DRM (`cenc:default_KID`)
- Prompting for decryption key when DRM is detected
- Playback state persistence via sessionStorage
- Error handling with severity categorization
- Clean destruction on unmount via a `destroyed` safety flag

**VideoControls** (`src/components/VideoControls.tsx`) — The largest component (~715 lines). Custom overlay UI with 20+ state variables managing:
- Play/pause, seek bar, volume slider, quality/speed/audio/subtitle popups
- Auto-hide (3s inactivity timer)
- Sleep/wake recovery (visibilitychange + timer-gap detection with 5s guard window)
- Right-click context menu (Stats toggle) rendered via React portal
- Fullscreen API integration

**StatsPanel** (`src/components/StatsPanel.tsx`) — Real-time diagnostics overlay (13 stat rows, 1s update interval). Accessed via right-click context menu. Uses browser PlaybackQuality API with Shaka stats fallback.

**FilmstripTimeline** (`src/components/FilmstripTimeline.tsx`) — Canvas-based filmstrip panel below the video. Renders a zoomable/scrollable timeline with thumbnails generated by a web worker. Accepts an optional `clearKey` prop for encrypted content. Features:
- Two rendering modes: *packed* (one I-frame thumbnail per segment, segment width ≤ thumbnail width) and *gap* (multiple intra-frame thumbnails per segment when zoomed in)
- Per-segment bitrate graph drawn below thumbnails with colored bars (measured vs estimated)
- GOP tooltip on hover over bitrate bars showing per-frame size bars and per-type stats
- Save frame via right-click context menu with CTS-based time snapping
- Color-coded frame borders: red=I, blue=P, green=B

**useThumbnailGenerator** (`src/hooks/useThumbnailGenerator.ts`) — Hook that manages the thumbnail worker lifecycle. Extracts segment URLs from Shaka's manifest, spawns the worker, and handles lazy-loading based on visible viewport. When `clearKey` is provided for encrypted streams, passes the hex key to the worker for self-decryption. Exposes:
- `thumbnails` — `Map<number, ImageBitmap>`: I-frame thumbnails keyed by segment start time
- `intraFrames` — `Map<number, ImageBitmap[]>`: multiple decoded bitmaps per segment for gap mode
- `intraFrameTypes` — `Map<number, FrameType[]>`: I/P/B types for each intra bitmap
- `intraTimestamps` — `Map<number, number[]>`: exact CTS seconds for each intra bitmap (from mp4box, includes composition time offsets)
- `gopStructures` — `Map<number, GopFrame[]>`: frame types + byte sizes for GOP tooltip
- `saveFrame(time)` — one-shot full-resolution frame decode from the active stream
- Memory eviction: bitmaps outside 3× the visible viewport span are closed and removed

**thumbnailWorker** (`src/workers/thumbnailWorker.ts`) — Web Worker that fetches media segments, extracts samples via mp4box, decodes frames with VideoDecoder, and posts back ImageBitmaps. For CENC-encrypted content, integrates with `cencDecrypt` to decrypt samples before decoding. Key subsystems:

- **I-frame thumbnails** (`processQueue`): extracts sync samples only, decodes one I-frame per segment for the packed filmstrip view
- **Intra-frame generation** (`handleGenerateIntra`): decodes ALL frames in a segment, captures N evenly-spaced bitmaps for gap mode. Returns exact CTS timestamps alongside bitmaps so the component can snap to real presentation times
- **Frame type classification** (`classifyFrameTypes`): max-CTS heuristic — iterates samples in decode order tracking the highest CTS seen; sync samples → I, non-sync with CTS ≥ maxCts → P, non-sync with CTS < maxCts → B. Returns `GopFrame[]` in display (CTS) order with byte sizes
- **Active stream frame types** (`getActiveFrameTypes`): classifies from the watched rendition (e.g. 1080p) rather than the lowest-quality thumbnail stream, since different renditions may have different GOP structures. Results are cached by segment URL
- **Save frame** (`handleSaveFrame`): decodes all frames in the target segment at full resolution, captures the one whose `frame.timestamp` matches the target CTS within half a frame duration tolerance. Uses timestamp matching (not output counting) for robustness against decoder reordering
- **GOP structure** (`requestGop`): lightweight handler that classifies frame types without video decoding, used for the GOP tooltip on hover

**useBitrateGraph** (`src/hooks/useBitrateGraph.ts`) — Hook that computes per-segment bitrate for the filmstrip graph. Data sources in priority order:
1. Measured from network via Shaka's response filter (actual `response.data.byteLength`)
2. Byte-range metadata from segment references in the manifest
3. Estimated from the variant's declared `bandwidth` (lighter color in graph)

Formula: `bitrateBps = (bytes × 8) / segmentDuration`. Listens to `variantchanged`/`adaptation` events for rendition switches and retains historical measurements across switches.

**filmstripFrameMapping** (`src/utils/filmstripFrameMapping.ts`) — Pure functions modeling the save-frame pipeline for testability. Three stages that must agree:
1. Paint loop frame assignment: slot index → `captureIndices[arrIdx]` → which frame is displayed
2. Context-menu snap: click pixel → snapped time (using exact CTS timestamps or FPS approximation)
3. Worker CTS match: snapped time → closest frame CTS → decoded frame

The diagnostic test (`filmstripFrameMapping.test.ts`) runs the full pipeline at every zoom level (packed through max) with composition time offsets (0–3 frames) and reports mismatches. Run with `npx vitest run src/utils/filmstripFrameMapping.test.ts`.

**cencDecrypt** (`src/workers/cencDecrypt.ts`) — CENC decryption utility for ClearKey DRM in the thumbnail worker. Parses `tenc` and `schm` boxes from mp4box's tree, manually parses `senc` boxes from raw segment bytes (mp4box's senc parser is disabled), and performs AES-128-CTR decryption via Web Crypto API with subsample support. Key details:
- Only supports `cenc` scheme (AES-CTR); bails on `cbcs`/`cbc1`
- IV is right-padded to 16 bytes per CENC spec
- With subsamples: concatenates encrypted ranges into a single decrypt call, then re-interleaves with clear bytes
- Decryption is fully opt-in — gated on `clearKeyHex` being provided in the worker message

**Utilities** in `src/utils/`: `formatTime`, `formatTrackRes`, `safeNum`, `formatBitrate` — small pure functions.

## Frame Analysis Pitfalls

Things to watch out for when working with frame-level video data:

- **Composition time offsets (CTTS)**: With B-frame reordering, mp4box CTS values are shifted by N frame durations past the segment start time. Never compute frame CTS as `segStart + frameIdx / fps` — always use actual CTS from mp4box samples. This shift varies by encoder and GOP structure.
- **Decode order ≠ display order**: mp4box returns samples in decode (DTS) order. VideoDecoder outputs in display (CTS) order. The `classifyFrameTypes` heuristic works on decode order but returns results sorted by CTS.
- **Different renditions, different GOPs**: A 240p stream may use IPP structure while the 1080p stream uses IBBP. Always classify frame types from the active (watched) stream, not the thumbnail stream.
- **VideoDecoder output counting is fragile**: Don't rely on output frame count matching input sample count. Match decoded frames by `frame.timestamp` against the target CTS instead.
- **Filmstrip click time ≠ frame CTS**: The pixel-to-time conversion from a filmstrip click gives a timeline position, not a frame's actual CTS. Use exact CTS timestamps from the worker (stored in `intraTimestamps`) to snap click times to real frame positions.
- **Packed vs gap mode**: At low zoom the filmstrip shows one I-frame per segment (packed); zoomed in it shows multiple intra-frames per segment (gap). The save-frame context menu must snap differently for each mode.

## Testing

Tests use Vitest + React Testing Library + jsdom. Test files live alongside source: `src/**/*.test.{ts,tsx}`.

Mock helpers in `src/test/helpers/`:
- `createMockVideoElement.ts` — mock HTMLVideoElement with event listener tracking
- `createMockShakaPlayer.ts` — mock Shaka Player instance with variant/audio/text tracks

Setup file: `src/test/setup.ts` (jest-dom matchers, automatic cleanup).

## Conventions

- CSS classes prefixed with `vp-` (vibe player)
- Shaka Player types accessed via the `shaka` global namespace
- Strict TypeScript (`strict: true`, `noUnusedLocals`, `noUnusedParameters`)
- Functional components with hooks only (no class components)
