# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## What This Is

R&D Player — a custom web video player built with React 19, TypeScript, and Shaka Player 5 for adaptive streaming (DASH/HLS). Replaces native browser controls with a dark-themed custom overlay. Supports ClearKey DRM auto-detection, multi-track audio/subtitles, playback diagnostics, and sleep/wake recovery.

## Commands

- `npm run dev` — Start Vite dev server with HMR
- `npm run build` — TypeScript check + Vite production build
- `npm run lint` — ESLint (flat config, ESLint 9+)
- `npm run test` — Vitest in watch mode
- `npm run test:run` — Vitest single run (CI mode)
- `npm run test:coverage` — Coverage report
- Run a single test file: `npx vitest run src/utils/formatTime.test.ts`

## Architecture

Entry: `index.html` → `src/main.tsx` → `src/App.tsx`

**App.tsx** — Root component. Renders a URL input form; on submit passes the manifest URL to ShakaPlayer.

**ShakaPlayer** (`src/components/ShakaPlayer.tsx`) — Bridge between React and the native Shaka Player library. Handles:
- One-time polyfill installation at module level
- Manifest fetching to auto-detect ClearKey DRM (`cenc:default_KID`)
- Prompting for decryption key when DRM is detected
- Playback state persistence via sessionStorage
- Error handling with severity categorization
- Clean destruction on unmount via a `destroyed` safety flag

**VideoControls** (`src/components/VideoControls.tsx`) — The largest component (~715 lines). Custom overlay UI with 20+ state variables managing:
- Play/pause, seek bar, volume slider, quality/speed/audio/subtitle popups
- Auto-hide (3s inactivity timer)
- Sleep/wake recovery (visibilitychange + timer-gap detection with 5s guard window)
- Right-click context menu (Stats toggle) rendered via React portal
- Fullscreen API integration

**StatsPanel** (`src/components/StatsPanel.tsx`) — Real-time diagnostics overlay (13 stat rows, 1s update interval). Accessed via right-click context menu. Uses browser PlaybackQuality API with Shaka stats fallback.

**FilmstripTimeline** (`src/components/FilmstripTimeline.tsx`) — Canvas-based filmstrip panel below the video. Renders a zoomable/scrollable timeline with thumbnails generated by a web worker. Accepts an optional `clearKey` prop for encrypted content. Features:
- Two rendering modes: *packed* (one I-frame thumbnail per segment, segment width ≤ thumbnail width) and *gap* (multiple intra-frame thumbnails per segment when zoomed in)
- Per-segment bitrate graph drawn below thumbnails with colored bars (measured vs estimated)
- GOP tooltip on hover over bitrate bars showing per-frame size bars and per-type stats
- Save frame via right-click context menu with position-based frame targeting (see Save Frame Pipeline below)
- Color-coded frame borders: red=I, blue=P, green=B

**useThumbnailGenerator** (`src/hooks/useThumbnailGenerator.ts`) — Hook that manages the thumbnail worker lifecycle. Extracts segment URLs from Shaka's manifest, spawns the worker, and handles lazy-loading based on visible viewport. When `clearKey` is provided for encrypted streams, passes the hex key to the worker for self-decryption. Exposes:
- `thumbnails` — `Map<number, ImageBitmap>`: I-frame thumbnails keyed by segment start time
- `intraFrames` — `Map<number, ImageBitmap[]>`: multiple decoded bitmaps per segment for gap mode
- `intraFrameTypes` — `Map<number, FrameType[]>`: I/P/B types for each intra bitmap
- `intraTimestamps` — `Map<number, number[]>`: exact CTS seconds for each intra bitmap (from mp4box, includes composition time offsets)
- `gopStructures` — `Map<number, GopFrame[]>`: frame types + byte sizes for GOP tooltip
- `saveFrame(time, framePosition?)` — one-shot full-resolution frame decode from the active stream; `framePosition` (0..1) identifies the frame by display-order index to avoid cross-stream CTS mismatches
- Memory eviction: bitmaps outside 3× the visible viewport span are closed and removed

**thumbnailWorker** (`src/workers/thumbnailWorker.ts`) — Web Worker that fetches media segments, extracts samples via mp4box, decodes frames with VideoDecoder, and posts back ImageBitmaps. For CENC-encrypted content, integrates with `cencDecrypt` to decrypt samples before decoding. Key subsystems:

- **I-frame thumbnails** (`processQueue`): extracts sync samples only, decodes one I-frame per segment for the packed filmstrip view
- **Intra-frame generation** (`handleGenerateIntra`): decodes ALL frames in a segment, captures N evenly-spaced bitmaps for gap mode. Returns exact CTS timestamps alongside bitmaps so the component can snap to real presentation times
- **Frame type classification** (`classifyFrameTypes`): max-CTS heuristic — iterates samples in decode order tracking the highest CTS seen; sync samples → I, non-sync with CTS ≥ maxCts → P, non-sync with CTS < maxCts → B. Returns `GopFrame[]` in display (CTS) order with byte sizes
- **Active stream frame types** (`getActiveFrameTypes`): classifies from the watched rendition (e.g. 1080p) rather than the lowest-quality thumbnail stream, since different renditions may have different GOP structures. Results are cached by segment URL
- **Save frame** (`handleSaveFrame`): decodes all frames in the target segment at full resolution. When `framePosition` is provided (0..1), captures by display-order output index (`Math.round(position * (totalFrames - 1))`), which is immune to cross-stream CTS mismatches. Falls back to CTS-based timestamp matching when no position is given
- **GOP structure** (`requestGop`): lightweight handler that classifies frame types without video decoding, used for the GOP tooltip on hover

**useBitrateGraph** (`src/hooks/useBitrateGraph.ts`) — Hook that computes per-segment bitrate for the filmstrip graph. Data sources in priority order:
1. Measured from network via Shaka's response filter (actual `response.data.byteLength`)
2. Byte-range metadata from segment references in the manifest
3. Estimated from the variant's declared `bandwidth` (lighter color in graph)

Formula: `bitrateBps = (bytes × 8) / segmentDuration`. Listens to `variantchanged`/`adaptation` events for rendition switches and retains historical measurements across switches.

**filmstripFrameMapping** (`src/utils/filmstripFrameMapping.ts`) — Pure functions modeling the save-frame pipeline for testability. Three stages that must agree:
1. Paint loop frame assignment: slot index → `captureIndices[arrIdx]` → which frame is displayed
2. Context-menu snap: click pixel → slot → `arrIdx` → normalized `framePosition` (0..1)
3. Worker frame capture: `framePosition` → `Math.round(position * (totalFrames - 1))` → display-order output index

The diagnostic test (`filmstripFrameMapping.test.ts`) runs the full pipeline at every zoom level (packed through max) with composition time offsets (0–3 frames) and cross-stream CTS mismatches. Run with `npx vitest run src/utils/filmstripFrameMapping.test.ts`.

**cencDecrypt** (`src/workers/cencDecrypt.ts`) — CENC decryption utility for ClearKey DRM in the thumbnail worker. Parses `tenc` and `schm` boxes from mp4box's tree, manually parses `senc` boxes from raw segment bytes (mp4box's senc parser is disabled), and performs AES-128-CTR decryption via Web Crypto API with subsample support. Key details:
- Only supports `cenc` scheme (AES-CTR); bails on `cbcs`/`cbc1`
- IV is right-padded to 16 bytes per CENC spec
- With subsamples: concatenates encrypted ranges into a single decrypt call, then re-interleaves with clear bytes
- Decryption is fully opt-in — gated on `clearKeyHex` being provided in the worker message

**Utilities** in `src/utils/`: `formatTime`, `formatTrackRes`, `safeNum`, `formatBitrate` — small pure functions.

## Save Frame Pipeline

The "Save frame" feature must capture the exact frame the user sees in the filmstrip. This is non-trivial because the filmstrip thumbnails come from the **lowest-quality** stream (e.g. 240p) while saving uses the **active** stream (e.g. 1080p), and these streams can have different composition time offsets.

**The problem**: CTS-based matching fails across streams. If the 240p stream has no B-frames (CTTS offset=0) and the 1080p stream uses IBBP (CTTS offset=2), frame N has CTS `N/fps` in one stream but `(N+2)/fps` in the other. Sending a CTS time from the thumbnail stream to the active stream produces systematic off-by-N errors.

**The solution**: Position-based frame identification. Instead of sending a CTS timestamp, the component computes a **normalized frame position** (0.0 = first frame, 1.0 = last frame) from the bitmap array index, and the worker maps it to a display-order output index in whatever stream it decodes from. Display-order frame indices are consistent across renditions of the same segment.

Pipeline steps:
1. **Paint loop** draws bitmap at `arrIdx = round(slotJ / (slotCount-1) * (intraCount-1))`
2. **Context menu** computes `framePosition = arrIdx / (intraCount-1)` — a stream-independent 0..1 value
3. **Worker** receives `framePosition`, computes `targetIdx = round(position * (totalFrames-1))`, captures the Nth VideoDecoder output

For **packed mode** (one thumbnail per segment), `framePosition = 0` (the I-frame / first frame).

## Frame Analysis Pitfalls

Things to watch out for when working with frame-level video data:

- **Composition time offsets (CTTS)**: With B-frame reordering, mp4box CTS values are shifted by N frame durations past the segment start time. Never compute frame CTS as `segStart + frameIdx / fps` — always use actual CTS from mp4box samples. This shift varies by encoder and GOP structure.
- **Cross-stream CTS mismatch**: The thumbnail stream and active stream may have different CTTS offsets (e.g. 240p IPP offset=0 vs 1080p IBBP offset=2). Never use CTS from one stream to identify frames in another. Use normalized frame position (0..1) instead — display-order frame indices are consistent across renditions.
- **Decode order ≠ display order**: mp4box returns samples in decode (DTS) order. VideoDecoder outputs in display (CTS) order. The `classifyFrameTypes` heuristic works on decode order but returns results sorted by CTS.
- **Different renditions, different GOPs**: A 240p stream may use IPP structure while the 1080p stream uses IBBP. Always classify frame types from the active (watched) stream, not the thumbnail stream.
- **VideoDecoder output counting**: When feeding ALL samples to a one-shot decoder for save-frame, output counting by display-order index is reliable and preferred over CTS matching (which breaks across streams). For partial feeds or streaming decode, use timestamp matching instead.
- **Filmstrip click time ≠ frame CTS**: The pixel-to-time conversion from a filmstrip click gives a timeline position, not a frame's actual CTS. The context menu maps click position → slot → arrIdx → framePosition, bypassing CTS entirely for the save path.
- **Packed vs gap mode**: At low zoom the filmstrip shows one I-frame per segment (packed); zoomed in it shows multiple intra-frames per segment (gap). Packed mode always saves the first frame (position=0); gap mode computes position from the slot's bitmap array index.
- **Frame-step seek epsilon**: The ArrowRight/ArrowLeft handlers in `useKeyboardShortcuts.ts` add `FRAME_SEEK_EPSILON = 0.001` (1 ms) to the computed seek target. Without this, Firefox's MSE implementation lands slightly *before* the exact frame boundary (`N/fps - epsilon`), displaying frame N-1 instead of N. At 30 fps (33 ms/frame), 1 ms cannot overshoot: `Math.round((N/fps + 0.001) * fps) = N`. The epsilon is safe for consecutive steps — no drift accumulates because each step recomputes `Math.round(currentTime * fps)` to snap to the current frame before adding ±1. Do not remove it without verifying Firefox OCR tests pass.

## Testing

Two separate test layers: **unit tests** (Vitest, jsdom) and **E2E tests** (Playwright, real browsers).

### Unit Tests

Vitest + React Testing Library + jsdom. Test files live alongside source: `src/**/*.test.{ts,tsx}`.

```bash
npm run test              # watch mode
npm run test:run          # single run (CI)
npm run test:coverage     # coverage report
npx vitest run src/utils/formatTime.test.ts   # single file
```

Mock helpers in `src/test/helpers/`:
- `createMockVideoElement.ts` — mock HTMLVideoElement with event listener tracking and `_emit(event)` for simulating media events
- `createMockShakaPlayer.ts` — mock Shaka Player instance with variant/audio/text tracks and `_emit(event)` for Shaka events

Setup file: `src/test/setup.ts` (jest-dom matchers, automatic cleanup).

Component tests (e.g. `ShakaPlayer.test.tsx`) mock the entire `shaka-player` module and `fetch` to prevent real network access. The `destroyed` safety flag and async lifecycle are tested by triggering unmount mid-load.

### E2E Tests

Playwright across 4 browser projects: Chromium, Firefox, WebKit, Edge. Test files in `e2e/`.

```bash
npm run test:e2e                            # all browsers
npx playwright test --project=chromium      # specific browser
npx playwright test --project=edge          # Edge (requires Edge installed)
npx playwright test e2e/smoke.spec.ts       # specific file
npx playwright test --project=chromium --headed   # headed for debugging
npx playwright show-report                  # view HTML report after run
```

**Config** (`playwright.config.ts`): Vite dev server starts automatically via `webServer`. In CI: 1 worker, 2 retries, blob reporter. Locally: parallel workers, 0 retries, HTML reporter. Dev server is reused locally (`reuseExistingServer: !process.env.CI`).

**Test suites:**
- `e2e/smoke.spec.ts` — 7 tests. Page title, URL form, query parameter bypass, empty submission. No video loading needed.
- `e2e/player-controls.spec.ts` — 13 tests. Play/pause, timecode, speed selector, volume mute/slider, seek bar, right-click context menu, stats panel toggle, keyboard shortcuts (Space, M), auto-hide (3s timer). All use `loadPlayerWithFixture()`.
- `e2e/ocr.spec.ts` — 12 tests. OCR-based frame verification using the DASH fixture (see OCR Tests below).
- `e2e/filmstrip.spec.ts` — 8 tests. Filmstrip panel toggle, thumbnail loading, zoom in/out, and zoom extremes using the DASH fixture (see Filmstrip Tests below).
- `e2e/screenshot.spec.ts` — Screenshot capture test using the DASH fixture.
- `e2e/encrypted.spec.ts` — 4 tests. Encrypted DASH playback via ClearKey DRM, frame stepping, and filmstrip thumbnail decryption (see Encrypted Tests below).

**Fixture approach** (`e2e/helpers.ts`): Three fixture types serve different test needs:

1. **MP4 fixture** — A 3.3 KB H.264 MP4 file (`e2e/fixtures/test-video.mp4`) read into memory at module load time. `loadPlayerWithFixture(page)` intercepts requests via `page.route()` and serves the fixture bytes directly — no network, no CDN, deterministic. Used by smoke and player-controls tests.

2. **DASH fixture** — A 60-second multi-bitrate DASH stream (5 renditions, 240p–1080p) with a 4-digit frame counter overlay (white text, fontsize 120, centered on black). Generated by `e2e/generate-dash-fixture.sh` at 30 fps with keyframes every second and 2-second segments. `loadPlayerWithDash(page)` serves the fixture files from memory via route interception, loads the player, then pauses and seeks to time 0. Gated on `DASH_FIXTURE_DIR` env var — tests using it call `isDashFixtureAvailable()` and skip when the fixture is absent. Used by OCR, filmstrip, and screenshot tests.

3. **Encrypted DASH fixture** — The same DASH stream re-packaged with CENC (AES-128-CTR) encryption via Shaka Packager. Generated by `e2e/generate-dash-fixture.sh` as a second step (requires `packager` in PATH). Output in `$DASH_FIXTURE_DIR/encrypted/`. Fixed ClearKey credentials: KID `00112233445566778899aabbccddeeff`, Key `0123456789abcdef0123456789abcdef`. Shaka Packager produces single-segment MP4 files with `SegmentBase` in the MPD, so the route handler supports byte-range requests (HTTP 206). `loadPlayerWithEncryptedDash(page)` serves encrypted files with Range header support, navigates to the player, waits for the `.vp-key-overlay` DRM prompt, enters the key, and waits for playback to initialize. Gated on `isEncryptedDashFixtureAvailable()`. Used by encrypted tests.

**Shared test utilities** (`e2e/helpers.ts`): Common functions used across multiple test files:
- `seekTo(page, time)` — seek + poll for `seeking=false` with retry loop
- `pressKeyAndSettle(page, key, shiftKey?)` — dispatch `KeyboardEvent` + wait for `seeked`
- `pressKeyNTimesAndSettle(page, key, count)` — batched N key presses in single `page.evaluate()`
- `readFrameNumber(page, ocr)` — crop screenshot + Tesseract OCR
- `openFilmstrip(page)` — right-click → "Filmstrip timeline"
- `waitForThumbnails(page, timeout?)` — poll canvas for bright pixels

### CI Matrix

GitHub Actions (`.github/workflows/ci.yml`) runs 7 jobs: 1 unit test + build job on Ubuntu, plus 6 E2E jobs:

| Runner | Browser | Notes |
|--------|---------|-------|
| `ubuntu-latest` | chromium | Standard |
| `ubuntu-latest` | firefox | Requires `gstreamer1.0-libav` for H.264 (see below) |
| `ubuntu-latest` | webkit | WebKitGTK (Linux rendering path) |
| `macos-latest` | webkit | Core Animation WebKit — closest to real Safari |
| `macos-latest` | firefox | VideoToolbox H.264 — tests Firefox WebCodecs (see below) |
| `windows-latest` | edge | Pre-installed Edge binary, `channel: "msedge"` |

`fail-fast: false` — all matrix entries run even if one fails. Blob reports are uploaded as artifacts (`blob-report-{os}-{browser}`, 14-day retention).

**Browser install per OS**: Ubuntu uses `npx playwright install --with-deps $BROWSER`. macOS installs the specific browser via `--with-deps $BROWSER`. Windows installs `chromium` deps (provides the driver); Edge itself is pre-installed on GitHub's Windows runners.

**Cost**: macOS runners cost 10× and Windows runners cost 2× vs Linux per minute. The suite runs in ~15s, so per-run cost is negligible.

### Platform-Specific Nuances

**Firefox on Linux lacks H.264 by default.** Playwright's Firefox relies on system GStreamer plugins for codec support. The `--with-deps` flag does not install `gstreamer1.0-libav`. Without it, `player.load()` fails silently (no codec error, just no playback) and controls never render, causing all player-controls tests to time out. The CI workflow has an explicit `sudo apt-get install -y gstreamer1.0-libav` step for the Ubuntu Firefox job.

**WebCodecs H.264 decoding works on all CI platforms.** Diagnostic probes confirmed that `VideoDecoder` successfully decodes H.264 on all 6 CI platforms (Chromium Linux, Firefox Linux, Firefox macOS, WebKit Linux, WebKit macOS, Edge Windows) in both main-thread and Worker contexts. Output pixel formats vary by platform: I420 (Chromium/Edge, Linux WebKit), BGRX (Firefox via GStreamer/VideoToolbox), NV12 (macOS WebKit). Linux WebKitGTK reports decoded frame height as 239 instead of 240 (GStreamer decoder rounding).

**WebKit behaves differently across OSes.** Playwright does not drive real Safari — it uses a patched WebKit engine. On Linux this is WebKitGTK (software rendering, different compositing path). On macOS it uses Core Animation and native media frameworks, matching real Safari behavior more closely. Both are tested in CI for coverage of rendering and codec differences.

**Edge is Chromium-based but not identical.** Driven via `channel: "msedge"` using the system Edge binary. Catches Edge-specific quirks (autoplay policy, media session API behavior). Requires Windows — the Edge project is only run on `windows-latest`.

**Debug panel overlap.** The dev-only `.vp-debug-panel` can overlap popup menus. The speed selector test hides it via `page.evaluate()` before interacting with popups. This is not needed in production builds.

### Former Approaches (Abandoned)

**VP8 WebM fixture for Firefox (commit `7fd3b4c`, reverted in `2430fa5`).** When Firefox H.264 failures were first discovered on CI, a VP8-encoded WebM fixture was added alongside the H.264 MP4. The helper accepted `browserName` and conditionally routed Firefox to the WebM file. This was reverted because: (1) it reduced test coverage — real streams use H.264, not VP8; (2) different codecs exercise different browser code paths, defeating the purpose of cross-browser testing; (3) the proper fix was installing the system codec (`gstreamer1.0-libav`), making Firefox decode H.264 identically to local development.

### Adding New E2E Tests

- Place test files in `e2e/*.spec.ts`
- For tests that need a loaded video player, use `loadPlayerWithFixture(page)` in `beforeEach`
- Use `.vp-*` CSS class selectors (see conventions below); combine with text content filters for resilience: `page.locator(".vp-popup-item", { hasText: "2x" })`
- Verify video state via `page.evaluate(() => document.querySelector("video")!.property)` rather than relying solely on UI state
- For timing-sensitive tests (auto-hide), add appropriate timeout buffers beyond the expected delay
- The `test-video.mp4` fixture is tiny (3.3 KB) and sufficient for control interaction tests; it is not suitable for testing adaptive streaming, DRM, or filmstrip features
- For tests that need the DASH fixture, use `loadPlayerWithDash(page)` and gate the file with `test.skip(!isDashFixtureAvailable(), ...)`

### OCR Tests

`e2e/ocr.spec.ts` — Uses **tesseract.js** (pure JS/WASM OCR, no system dependencies) to read the frame counter from the DASH fixture video and verify frame-accurate navigation. Works identically across all 5 CI browser/OS combinations.

```bash
DASH_FIXTURE_DIR=/tmp/dash-fixture npx playwright test e2e/ocr.spec.ts --project=chromium
```

**12 tests in 4 categories:**

| Category | Tests | What's verified |
|----------|-------|-----------------|
| Seek verification | t=0 → "0000", t=5 → "0150" | Correct frame at known timestamps |
| Frame stepping | ArrowRight +1, ArrowLeft -1, 3× ArrowRight, ArrowLeft at boundary | Single-frame precision of ←/→ keys |
| Navigation keys | Home, near-end seek (t=59), ArrowRight near end, Shift+Arrow ±1s | Keyboard navigation accuracy |
| Playback | Play ~1s, verify frame > 0 | Actual video playback advances frames |

**How it works:**
1. `readFrameNumber(page)` crops a screenshot to the center 30×15% of the video (where the frame counter is drawn), then runs Tesseract with digit-only whitelist and `PSM.SINGLE_WORD` mode
2. `seekTo(page, time)` sets `currentTime` and polls until `seeking === false`, with a retry loop to handle Shaka Player's internal DASH seeks that can override the target position
3. `pressKeyAndSettle(page, key, shiftKey?)` dispatches a `KeyboardEvent` directly via `page.evaluate()` (bypasses Playwright's `keyboard.press()` which doesn't reliably propagate `shiftKey`), then waits for the `seeked` event with a double-rAF paint wait
4. `pressKeyNTimesAndSettle(page, key, count)` runs N key presses inside a single `page.evaluate()`, waiting for `seeked` + `currentTime` change + double-rAF between each. This avoids Playwright round-trips that cause Edge's MSE pipeline to return stale `currentTime`, making consecutive steps no-op. Used for tests with 3+, 5+, or 10+ consecutive ArrowRight/ArrowLeft presses

**Technical pitfalls encountered:**
- **Playwright `keyboard.press("Shift+ArrowUp")` doesn't set `shiftKey`** on the dispatched event in all browsers. The fix is to dispatch `KeyboardEvent` directly via `page.evaluate()` with explicit `shiftKey: true`.
- **Stale `seeked` events from Shaka Player**: During DASH stream initialization, Shaka fires internal seeks. Event-listener-based waits (`addEventListener("seeked", ...)`) catch these stale events instead of the test's seek. Polling `video.seeking` is immune to this.
- **Shaka overriding seeks during init**: Setting `currentTime` immediately after load may be overwritten by Shaka's internal positioning. The `seekTo` retry loop re-issues `currentTime = t` until `Math.abs(currentTime - t) < 0.5`.
- **WebKit doesn't paint frame 0 without explicit seek**: After `loadPlayerWithDash()` pauses at t=0, WebKit may not have composited the first frame. An explicit `video.currentTime = 0` seek (even to the same position) forces the frame to be painted.
- **Tesseract drops leading zeros on Windows**: Font rendering differences on Windows cause Tesseract to read "0030" as "30". The fix is `text.trim().padStart(4, "0")` since the frame counter always uses 4-digit format.
- **Firefox MSE lands before exact frame boundaries**: Seeking to exactly `N/fps` on Firefox displays frame N-1 because the actual position is `N/fps - epsilon`. The fix is `FRAME_SEEK_EPSILON = 0.001` added to ArrowRight/ArrowLeft seek targets in `useKeyboardShortcuts.ts`. This is a player-code fix, not a test-only workaround.
- **Edge drops consecutive frame steps across Playwright round-trips**: Each `pressKeyAndSettle` is a separate `page.evaluate()`. Between calls, Edge's MSE pipeline hasn't flushed the new `currentTime` to the getter, so the next ArrowRight handler reads stale state and computes the same seek target (no-op). The fix is `pressKeyNTimesAndSettle()`, which runs all N steps inside a single `page.evaluate()` with per-step `seeked` event + `currentTime` change polling.

### Filmstrip Tests

`e2e/filmstrip.spec.ts` — Tests the filmstrip timeline panel: opening/closing, thumbnail rendering via WebCodecs `VideoDecoder`, and keyboard zoom. Uses the DASH fixture.

```bash
DASH_FIXTURE_DIR=/tmp/dash-fixture npx playwright test e2e/filmstrip.spec.ts --project=chromium
```

**8 tests in 3 categories:**

| Category | Tests | What's verified |
|----------|-------|-----------------|
| Toggle | Open via context menu, close via context menu, close via × button | Panel visibility, canvas presence, context menu text toggle ("Filmstrip timeline" ↔ "Hide filmstrip") |
| Thumbnail loading | Thumbnails render after loading | WebCodecs worker decodes segments and paints bright pixels on canvas |
| Zoom | `=` zooms in, `-` zooms out, max zoom-out (full timeline), max zoom-in (per-frame) | Canvas content changes, right-edge thumbnails visible at min zoom, blue P-frame borders appear at max zoom |

**How it works:**
1. `openFilmstrip(page)` hides the debug panel, right-clicks `.vp-video-area`, clicks "Filmstrip timeline", waits for `.vp-filmstrip-panel` visible
2. `waitForThumbnails(page)` polls canvas pixel data via `getImageData` at the thumbnail row midpoint (y=35px × DPR), checking that >5% of sampled pixels are bright (RGB > 80). The DASH fixture's white-on-black frame counter produces bright thumbnails vs the near-invisible placeholder `rgba(255,255,255,0.05)`
3. `pressKeyRepeatedly(page, key, count)` presses a key N times then waits for a double-rAF paint settle
4. `hasBrightPixelsInRegion(page, xFraction)` samples a 5%-width strip at a horizontal position to verify thumbnail content exists at that part of the timeline
5. `hasColoredFrameBorders(page)` scans for blue P-frame border pixels (B > 180, R < 100 after alpha compositing) which only appear in gap (per-frame) mode, never packed mode

All 8 tests run on all platforms. H.264 WebCodecs decoding works across all CI browsers (Chromium, Firefox, WebKit, Edge) on all OSes (Linux, macOS, Windows).

### Encrypted Tests

`e2e/encrypted.spec.ts` — Tests both decryption code paths using the encrypted DASH fixture: Shaka Player ClearKey DRM for video playback and `cencDecrypt.ts` for filmstrip thumbnail decryption.

```bash
DASH_FIXTURE_DIR=/tmp/dash-fixture npx playwright test e2e/encrypted.spec.ts --project=chromium
```

**4 tests in 3 categories:**

| Category | Tests | What's verified |
|----------|-------|-----------------|
| Seek verification | t=0 → "0000", t=5 → "0150" | Shaka Player ClearKey decryption works, seek accuracy with encrypted content |
| Frame stepping | ArrowRight → "0001" | Frame-accurate stepping with decryption |
| Filmstrip | Thumbnails render after loading | Worker `cencDecrypt.ts` AES-CTR decryption → VideoDecoder pipeline works |

**What's exercised:**
1. **Shaka Player DRM path** — `ShakaPlayer.tsx` auto-detects `cenc:default_KID` from the manifest, prompts for a key via `.vp-key-overlay`, and configures `drm.clearKeys` for playback
2. **Thumbnail worker CENC path** — `cencDecrypt.ts` parses `tenc`/`senc` boxes, performs AES-128-CTR decryption via Web Crypto API, then feeds decrypted samples to `VideoDecoder` for filmstrip thumbnails

**Fixture generation** requires Shaka Packager (`packager` binary) in PATH. The `e2e/generate-dash-fixture.sh` script reconstructs fragmented MP4s from the plaintext DASH output, then runs Shaka Packager with `--enable_raw_key_encryption --protection_scheme cenc --clear_lead 0`. If `packager` is not available, the encrypted fixture is skipped and tests are gated by `isEncryptedDashFixtureAvailable()`.

## Conventions

- CSS classes prefixed with `vp-` (vibe player)
- Shaka Player types accessed via the `shaka` global namespace
- Strict TypeScript (`strict: true`, `noUnusedLocals`, `noUnusedParameters`)
- Functional components with hooks only (no class components)
